## The routing function ################
########################################
routing_fun <- function(input_data, par=list(w, alpha_bf), GW0 = 100) {
# input_data is a data frame with at least Date and U (rainfall excess) as columns
# alpha_bf is the linear recession constant
# W is the fraction of direct runoff
# GW0 is the initial groundwater storage
GW <- vector() # storage vector for groundwater storage
Qf <- vector() # surface flow
Qs <- vector() # "slow" groundwater flow
Q <- vector() # streamflow
#initial value
GW[1] <- GW0
# run a loop start at i = 2 because i = 1 is initial value
for (i in 2:length(input_data$U)) {
# 1. Quick (surface) flow = w*U
Qf[i] <- par$w *input_data$U[i]
# 2. Slow flow output, calculate recession alpha_bf*GW_storage
Qs[i] <- par$alpha_bf * GW[i-1]
# Do the water balance of the groundwater storage
GW[i] <- GW[i-1] + (1-par$w)*input_data$U[i] - Qs[i]
# total streamflow, add slow and fast flows
Q[i] <- Qf[i] + Qs[i]
}
return(tibble(Date=input_data$Date, Q=Q,Qf=Qf,Qs=Qs ,GW= GW ))
}
########################################
########################################
## The final hydrological model ########
########################################
hydrological_model <- function(data, s_fc, k, w, alpha_bf, Zr=150, GW0=100) {
# call the functions
# 1. SMA function
Out.C <- SMA_fun(data, par=list(s_fc = s_fc , k = k ), Zr = Zr) #complete this function
# 2. Routing function. Notice that we have to use the output from our sma_function which is Out.C as an input here
Out.R <- routing_fun(Out.C,par=list(w = w , alpha_bf = alpha_bf ), GW0=GW0)  # complete this function
# drop the dates from Out.R
Out.R <- Out.R %>%
select(-Date)
# create output
return(cbind(Out.C,Out.R))
}
########################################
cotter_data <- read_csv("data/cotter_data_prac4.csv")
catchment_simulation <- hydrological_model(cotter_data, s_fc = ..., k= ..., w = ...,
alpha_bf = ...)
catchment_simulation <- hydrological_model(cotter_data, s_fc = 0.75, k= 5, w = 0.1,
alpha_bf = 0.01)
#catchment_simulation
catchment_simulation_long = catchment_simulation %>% pivot_longer(c(st, U, Q, Qf, Qs, GW),
names_to="Flow_components", values_to ="Flow")
ggplot(catchment_simulation_long, aes(Date, Flow, colour=Flow_components)) + geom_line() + theme_bw() +
facet_wrap(~Flow_components, scales ="free", ncol = 1)
cotter_calib <- cotter_data %>%
filter(Date >= ymd("2001-07-01") &
Date < ymd("2007-01-01"))
cotter_valid <- cotter_data %>%
filter(Date >= ymd("2008-07-01") &
Date < ymd("2011-12-31"))
# --------------------------------------
# Performance measures for calibration
# -------------------------------------
# calculate RMSE
RMSE <- function(in1,in2) {
out <-  sqrt(sum((in1 - in2)^2,na.rm=T))/length(in1)
return(out)
}
#calculate bias
bias <- function(in1,in2) {
out <-   sum((in1 - in2),na.rm=T)/length(in1)
return(out)
}
########################################################################################
# Larger values of the below given metrics are favoured for better models.
# Our optimization routine will focus on minimizing the values
# So we will artificially add a '-' to these metrics to reflect larger negative
# values are favoured!
# Incase you use these functions to do comparisons, makesure you take this conversion
# into account and report the correct values or use the perfomance function given at the end.
########################################################################################
# calculate r_squared ##################################################################
r_squared <- function(in1,in2) {
out <-   cor(in1,in2, use="complete.obs")^2
return(-1*out)
}
# calculate NSE ########################################################################
NSE <- function(in1,in2) {
out <- 1 - var((in1 - in2), na.rm=T)/var(in1, na.rm=T)
#print(out)
return(-1*out)
}
# calculate KGE ########################################################################
KGE <- function(in1,in2){
alpha <- var((in1 - in2), na.rm=T)/var(in1, na.rm=T)
beta <- bias(in1, in2)/var(in1, na.rm=T)
r <- cor(in1, in2, use="complete.obs")
out <- 1 - sqrt((r - 1)^2 + (alpha - 1)^2 + (beta - 1)^2)
return(-1*out)
}
# --------------------------------------------------------------------------------------
##########################################################################################
# This function spits out all the performance metrics in their correct values and signs!
##########################################################################################
performance <- function(in1,in2) {
RMSE_o <- RMSE(in1,in2)
bias_o <- bias(in1,in2)
r_sq_o <- r_squared(in1,in2)
NSE_o <- NSE(in1, in2)
KGE_o <- KGE(in1, in2)
return(tibble(RMSE = round(RMSE_o,3), bias = round(bias_o,3), r_squared = -1*round(r_sq_o,3),
NSE = -1*round(NSE_o,3), KGE = -1*round(KGE_o,3)))
}
##########################################################################################
performance(cotter_data$Flow_mm, catchment_simulation$Q)
# By default we want to go with NSE as the performance metric without a log transformation
performance_metric <- function(pars, data_in, perf_metric=NSE, log_transform= F) {
# organise the pars in order
s_fc<- pars[1]
k <- pars[2]
w <- pars[3]
alpha_bf<- pars[4]
Zr <- pars[5]
GW0 <- pars[6]
# 1.Build in a control/constraint so none of the parameters are negative (if so, performance should be a large positive number), also control for s_fc and w to be <= 1
########################################################################################################
if (any(c(s_fc, k, w, alpha_bf, Zr, GW0)<=0)==T | any(c(s_fc, w, alpha_bf)>=1) ==T) {
Performance <- 99999
} else {
# 2. Call the catch_fun and run the model
##########################################
model_out <- hydrological_model(data_in, s_fc = s_fc, k= k, w = w,
alpha_bf = alpha_bf, Zr = Zr, GW0 = GW0)                    # complete this line
# model_out is now a tibble with the model output
# We want to compare Q in model_out with Flow_mm in the input data
#browser()
# 3. Choose whether to do a log transform or not and also select the performance metric. If none is
# given, it will take NSE as the default performance metric.
############################################################
if (log_transform == F){
Performance <- perf_metric(data_in$Flow_mm, model_out$Q)  # complete this line
} else{
Performance <- perf_metric(log10(data_in$Flow_mm+1), log10(model_out$Q+1))  # complete this line
}
}
# 4. Return the final performance
#################################
return(Performance)
}
# order of the parameters s_fc, k, w, alpha_bf, Zr, GW0
performance_metric(pars=c(0.75, 3, 0.1, 0.01,150,100), data_in = cotter_calib, log_transform=T)
performance_metric(pars=c(0.75, -3, 0.1, 0.01,150,100), data_in = cotter_calib)
init_pars <- c(0.2, 2, 0.1, 0.01, 150, 50)
calib_result <- optim(init_pars, performance_metric, control = list(maxit = 20000),
data_in = cotter_calib)
calib_result
round(calib_result$par,2)
calibration_predict <- hydrological_model(data= cotter_calib, calib_result$par[1], calib_result$par[2],
calib_result$par[3], calib_result$par[4], calib_result$par[5],
calib_result$par[6])
calibration_predict_converged = calibration_predict %>%
mutate(Q_observed = cotter_calib$Flow_mm) %>%
filter(Date >= ymd('2008-01-01'))
View(calibration_predict_compare)
calibration_predict_converged = rename(calibration_predict_converged,  Q_predicted = Q)
calibration_predict_converged
calibration_predict_converged = calibration_predict %>%
mutate(Q_observed = cotter_calib$Flow_mm) %>%
filter(Date >= ymd('2008-01-01'))
calibration_predict_converged
View(calibration_predict)
calibration_predict_converged = calibration_predict %>%
mutate(Q_observed = cotter_calib$Flow_mm) %>%
filter(Date >= ymd('2002-01-01'))
calibration_predict_converged = rename(calibration_predict_converged,  Q_predicted = Q)
calibration_predict_converged
performance(calibration_predict_converged$Q_observed , calibration_predict_converged$Q_predicted)
calibration_predict_long =  calibration_predict_converged %>%
pivot_longer(c(Q_predicted,Q_observed), names_to='Flow', values_to= 'mm')
#this bit of new code help us manipulate the plot size :)
options(repr.plot.width =8, repr.plot.height =3)
ggplot(calibration_predict_long, aes(Date, mm, colour=Flow)) +geom_line() + theme_bw()
g2 <- dagitty( "dag {
Farms-research-facilities -> student-population -> Water-use
Farms-research-facilities -> researcher-population -> Water-use
Farms-research-facilities -> beef-production -> Water-use -> water-quality
Farms-research-facilities -> beef-production -> air_quality -> Greenhouse_gasses -> Global_warming -> Rainfall
Rainfall -> beef-production -> erosion -> water_quality
Rainfall -> Drought -> beef-production -> water_quality
}")
require(dagitty)
g2 <- dagitty( "dag {
Farms-research-facilities -> student-population -> Water-use
Farms-research-facilities -> researcher-population -> Water-use
Farms-research-facilities -> beef-production -> Water-use -> water-quality
Farms-research-facilities -> beef-production -> air_quality -> Greenhouse_gasses -> Global_warming -> Rainfall
Rainfall -> beef-production -> erosion -> water_quality
Rainfall -> Drought -> beef-production -> water_quality
}")
plot(graphLayout(g2))
g2 <- dagitty( "dag {
Farms_research_facilities -> student_population -> Water_use
Farms-research_facilities -> researcher-population -> Water_use
Farms-research_facilities -> beef_production -> Water_use -> water_quality
Farms-research_facilities -> beef_production -> air_quality -> Greenhouse_gasses -> Global_warming -> Rainfall
Rainfall -> beef_production -> erosion -> water_quality <- managing_mass_flows
Rainfall -> Drought -> beef_production -> water_quality <- managing_mass_flows
}")
plot(graphLayout(g2))
g2 <- dagitty( "dag {
Farms_research_facilities -> student_population -> Water_use
Farms-research_facilities -> researcher-population -> Water_use
Farms_research_facilities -> beef_production -> Water_use -> water_quality
Farms_research_facilities -> beef_production -> air_quality -> Greenhouse_gasses -> Global_warming -> Rainfall
Rainfall -> beef_production -> erosion -> water_quality <- managing_mass_flows
Rainfall -> Drought -> beef_production -> water_quality <- managing_mass_flows
}")
plot(graphLayout(g2))
g2 <- dagitty( "dag {
Farms_research_facilities -> student_population -> Water_use
Farms_research_facilities -> researcher_population -> Water_use
Farms_research_facilities -> beef_production -> Water_use -> water_quality
Farms_research_facilities -> beef_production -> air_quality -> Greenhouse_gasses -> Global_warming -> Rainfall
Rainfall -> beef_production -> erosion -> water_quality <- managing_mass_flows
Rainfall -> Drought -> beef_production -> water_quality <- managing_mass_flows
}")
plot(graphLayout(g2))
g2 <- dagitty( "dag {
Farms_research_facilities -> student_population -> Water_use
Farms_research_facilities -> researcher_population -> Water_use
Farms_research_facilities -> beef_production -> Water_use -> water_quality
Farms_research_facilities -> beef_production -> air_quality -> Greenhouse_gasses -> Global_warming -> Rainfall
Rainfall -> beef_production -> erosion -> water_quality <- managing_mass_flows
Rainfall -> beef_production -> erosion <- erosion_control
Rainfall -> Drought -> beef_production -> water_quality <- managing_mass_flows
}")
plot(graphLayout(g2))
g2 <- dagitty( "dag {
Farms_research_facilities -> student_population -> Water_use
Farms_research_facilities -> researcher_population -> Water_use
Farms_research_facilities -> beef_production -> Water_use -> water_quality
Farms_research_facilities -> beef_production -> air_quality -> Greenhouse_gasses -> Global_warming -> Rainfall
Rainfall -> beef_production -> erosion -> water_quality <- managing_mass_flows <- bio_remediation
Rainfall -> beef_production -> erosion <- erosion_control
Rainfall -> Drought -> beef_production -> water_quality <- managing_mass_flows
}")
g2 <- dagitty( "dag {
Farms_research_facilities -> student_population -> Water_use
Farms_research_facilities -> researcher_population -> Water_use
Farms_research_facilities -> beef_production -> Water_use -> water_quality
Farms_research_facilities -> beef_production -> air_quality -> Greenhouse_gasses -> Global_warming -> Rainfall
Rainfall -> beef_production -> erosion -> water_quality <- managing_mass_flows <- bio_remediation
Rainfall -> beef_production -> erosion <- erosion_control
Rainfall -> Drought -> beef_production -> water_quality <- managing_mass_flows
}")
plot(graphLayout(g2))
g2 <- dagitty( "dag {
Farms_research_facilities -> student_population -> Water_use
Farms_research_facilities -> researcher_population -> Water_use
Farms_research_facilities -> beef_production -> Water_use -> water_quality
Farms_research_facilities -> beef_production -> air_quality -> GHG_emissions -> Global_warming -> Rainfall
Rainfall -> beef_production -> erosion -> water_quality <- managing_mass_flows <- bio_remediation
Rainfall -> beef_production -> erosion <- erosion_control
Rainfall -> Drought -> beef_production -> water_quality <- managing_mass_flows
}")
plot(graphLayout(g2))
library(tidyverse)
library(plotly)
library(readxl)
library(htmlwidgets)
source("Functions_Rain.R")
files <- read_list_files("../Rain")
files
name <- files$names[[1]][5]
file_path <- files$paths[[which(files$names[[1]]==name)]]
files <- read_list_files("../Rain")
files
name <- files$names[[1]][5]
file_path <- files$paths[[which(files$names[[1]]==name)]]
files$names
files$names[[1]]
files$names[5]
name <- files$names[5]
file_path <- files$paths[[which(files$names[5]==name)]]
test_data <- read_data_file(name, file_path)
test_data
file_path_in <- "../Rain"
file_path_in
process_rain_data_auto <- function(file_path, output_path_add = "processed"){
#browser()
# step 1
input <- read_list_files(file_path)
# input is a list
browser()
# Loop through each .csv file
for (name in input$names) {
data_process <- read_data_file(name, file_path)
# # Read the .csv file
# difference the events column
data_process1 <- diff_data(data_process)
# write to otip file
out <- write_otip_file(name, data_process1, input = input, output_path_add)
cat("Processed file:", out$file, "Saved output to:", paste(out$path, output_path_add,sep="/"), "\n")
}
}
file_path_in <- "../Rain"
test_files <- process_rain_data_auto(file_path = file_path_in, output_path_add = "processed")
process_rain_data_auto <- function(file_path, output_path_add = "processed"){
#browser()
# step 1
input <- read_list_files(file_path)
# input is a list
#browser()
# Loop through each .csv file
for (name in input$names) {
data_process <- read_data_file(name, file_path)
# # Read the .csv file
# difference the events column
data_process1 <- diff_data(data_process)
# write to otip file
out <- write_otip_file(name, data_process1, input = input, output_path_add)
cat("Processed file:", out$file, "Saved output to:", paste(out$path, output_path_add,sep="/"), "\n")
}
}
create_data_list <- function(path_to_processed, file_numbers = "all"){
#write empty list to store the files
data2_list<-list()
#browser()
input <- read_list_files(path_to_processed)
# input is a list
# if file_numbers is a number or series of numbers
if (file_numbers != "all") {
input_names <- input$names[file_numbers]
} else input_names <-  input$names
# Loop through each .csv file
for (name in input_names) {
# Read the .csv file
data <- read_otip_file(name, path_to_processed)
# Check if "R1" or "R7" is in the file name at specific positions (e.g., at the beginning)
#file_name <- basename(user_file_paths)
browser()
if (grepl("R1|R7", name)){
# Apply transformations based on file name
data2 <- data %>%
mutate(tipRainmm = Event * 0.254)%>%
mutate(CumRainmm = cumsum(tipRainmm))%>%
select(date,CumRainmm) # If "R1" or "R7" is in the file name
} else {
# Default transformation
data2 <- data %>%
mutate(tipRainmm = Event * 0.1)%>%
mutate(CumRainmm = cumsum(tipRainmm))%>%
select(date,CumRainmm)# Default transformation for other cases
}
#browser()
# add the user_file_name to the list
data2 <- data2 %>%
mutate(filename = name)
# Add data2 to the list
data2_list[[name]] <- data2
cat("Processed file:", path_to_processed, "\n")
}
return(data2_list)
}
data_processed <- create_data_list(path_to_processed = "../Rain/processed")
data
head(data)
View(data)
create_data_list <- function(path_to_processed, file_numbers = "all"){
#write empty list to store the files
data2_list<-list()
#browser()
input <- read_list_files(path_to_processed)
# input is a list
# if file_numbers is a number or series of numbers
if (file_numbers != "all") {
input_names <- input$names[file_numbers]
} else input_names <-  input$names
# Loop through each .csv file
for (name in input_names) {
# Read the .csv file
data <- read_otip_file(name, path_to_processed)
# Check if "R1" or "R7" is in the file name at specific positions (e.g., at the beginning)
#file_name <- basename(user_file_paths)
browser()
if (grepl("R1|R7", name)){
# Apply transformations based on file name
data2 <- data %>%
mutate(tipRainmm = Event * 0.254)%>%
mutate(CumRainmm = cumsum(tipRainmm))%>%
select(Date,CumRainmm) # If "R1" or "R7" is in the file name
} else {
# Default transformation
data2 <- data %>%
mutate(tipRainmm = Event * 0.1)%>%
mutate(CumRainmm = cumsum(tipRainmm))%>%
select(Date,CumRainmm)# Default transformation for other cases
}
#browser()
# add the user_file_name to the list
data2 <- data2 %>%
mutate(filename = name)
# Add data2 to the list
data2_list[[name]] <- data2
cat("Processed file:", path_to_processed, "\n")
}
return(data2_list)
}
data_processed <- create_data_list(path_to_processed = "../Rain/processed")
b
create_data_list <- function(path_to_processed, file_numbers = "all"){
#write empty list to store the files
data2_list<-list()
#browser()
input <- read_list_files(path_to_processed)
# input is a list
# if file_numbers is a number or series of numbers
if (file_numbers != "all") {
input_names <- input$names[file_numbers]
} else input_names <-  input$names
# Loop through each .csv file
for (name in input_names) {
# Read the .csv file
data <- read_otip_file(name, path_to_processed)
# Check if "R1" or "R7" is in the file name at specific positions (e.g., at the beginning)
#file_name <- basename(user_file_paths)
# browser()
if (grepl("R1|R7", name)){
# Apply transformations based on file name
data2 <- data %>%
mutate(tipRainmm = Event * 0.254)%>%
mutate(CumRainmm = cumsum(tipRainmm))%>%
select(Date,CumRainmm) # If "R1" or "R7" is in the file name
} else {
# Default transformation
data2 <- data %>%
mutate(tipRainmm = Event * 0.1)%>%
mutate(CumRainmm = cumsum(tipRainmm))%>%
select(Date,CumRainmm)# Default transformation for other cases
}
#browser()
# add the user_file_name to the list
data2 <- data2 %>%
mutate(filename = name)
# Add data2 to the list
data2_list[[name]] <- data2
cat("Processed file:", path_to_processed, "\n")
}
return(data2_list)
}
data_processed <- create_data_list(path_to_processed = "../Rain/processed")
check_plot(data_processed)
source("C:/Users/rver4657/OneDrive - The University of Sydney (Staff)/Uruguay/LaCorona/lacorona_ncsu/ncsu/Scripts/Functions_Rain.R")
check_plot(data_processed)
check_plot(data_processed, plot = 2)
library(tidyverse)
library(plotly)
library(readtext)
source("Functions_well.R")
source("C:/Users/rver4657/OneDrive - The University of Sydney (Staff)/Uruguay/LaCorona/lacorona_ncsu/ncsu/Scripts/Functions_well.R")
source("Functions_well.R")
source("C:/Users/rver4657/OneDrive - The University of Sydney (Staff)/Uruguay/LaCorona/lacorona_ncsu/ncsu/Scripts/Functions_well.R")
source("C:/Users/rver4657/OneDrive - The University of Sydney (Staff)/Uruguay/LaCorona/lacorona_ncsu/ncsu/Scripts/Functions_well.R")
source("Functions_well.R")
setwd("C:/Users/rver4657/OneDrive - The University of Sydney (Staff)/Uruguay/LaCorona/lacorona_ncsu/ncsu/Scripts")
text_in_file <- readtext(paste("../Wells/Manual",
"Planilla cuenca 111219.docx", sep ="/"),
encoding = "utf8")$text
dates <- find_dates(text_in_file, "Data")
find_dates <- function(text_in, char_string = "Data") {
# find the dates on the sheets
line_dates <- str_locate_all(text_in,char_string)
dates <- list()
for (i in 1:nrow(line_dates[[1]])) {
dates[[i]] <- dmy(str_sub(text_in,line_dates[[1]][i,2]+1,
line_dates[[1]][i,2]+12))
}
return(tibble(dates = unlist(dates)))
}
source("C:/Users/rver4657/OneDrive - The University of Sydney (Staff)/Uruguay/LaCorona/lacorona_ncsu/ncsu/Scripts/Functions_well.R")
text_in_file <- readtext(paste("../Wells/Manual",
"Planilla cuenca 111219.docx", sep ="/"),
encoding = "utf8")$text
dates <- find_dates(text_in_file, "Data")
dates
?list
source("C:/Users/rver4657/OneDrive - The University of Sydney (Staff)/Uruguay/LaCorona/lacorona_ncsu/ncsu/Scripts/Functions_well.R")
text_in_file <- readtext(paste("../Wells/Manual",
"Planilla cuenca 111219.docx", sep ="/"),
encoding = "utf8")$text
dates <- find_dates(text_in_file, "Data")
dates
text_in_file <- readtext(paste("../Wells/Manual",
"Planilla cuenca 111219.docx", sep ="/"),
encoding = "utf8")$text
well_data_section <- doc_data_find(text_in = text_in_file,
feature_1 = "Wells",
feature_2 = "Rain\n")
well_data_section
well_data <- list()
# put the well tables in the list
for (i in 1:nrow(well_data_section)) {
well_data[[i]] <-
extract_well_sec(well_data_start = well_data_section[i,],
text_in = text_in_file,
text_string = "N.")
well_data[[i]] <- well_data[[i]] %>%
mutate(Date = dates$dates[i])
}
well_data
well_test <- read_manual_well("Planilla cuenca 111219.docx")
well_test
source("C:/Users/rver4657/OneDrive - The University of Sydney (Staff)/Uruguay/LaCorona/lacorona_ncsu/ncsu/Scripts/Functions_well.R")
